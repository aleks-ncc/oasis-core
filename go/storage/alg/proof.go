package alg

type NodeEntry struct {
	peer0, peer1  Hash
	compressedKey Key
}

// A ReadProof is a sequence of hash values generated by an ordered enumeration of peer hashes
// as we walk down the tree using the provided Key.
//
// Traversal order determines order of entries to the proof: the hashes are written in left,
// value, right order.  NB: compressed-key is not included, because that is an input to the
// hash for a node.  The ReadProof starts empty, and as we traverse we omit the hash for the
// branch that we go down, i.e., if the key bit is 0, we append the value hash, then the right
// hash, before recursing down to the left subtree.  No hashes are added on return from the
// recursion (so tail recursion optimization works), since we do not write boundary markers to
// make parsing of nested hash trees.  At the last entry of the ReadProof where we are at the
// node that corresponds to the key, we omit the value hash.  The returned data value provides
// the value hash.
//
// For a membership operation that results in "not-present" for a key, the MembershipProof will
// end at a node that is the node for the key but where the value hash is the "Empty"
// representation, or will be one where the node contains the key in the compressed Key bits
// associated with the node.  To verify, we check path so far to see if it exactly equals the
// desired key, in which case we use the EmptyHash value as the value hash, or if the key
// constructed by the walk (with compressedKey values) strictly contains the desired key, in
// which case the "extra" hash field will contain the value hash for that non-present final
// proof node.  (The value hash is for a value the key of which is a proper extension of the
// key in a query, since if they are equal we will have found the key and the value would have
// been returned.)
type MembershipProof struct {
	path  []NodeEntry
	extra Hash
}

func (pf *MembershipProof) Append(h0, h1 Hash, compressed Key) {
	pf.path = append(pf.path, NodeEntry{peer0: h0, peer1: h1, compressedKey: compressed})
}

type ReadProof struct {
	proof MembershipProof
}

func (rp *ReadProof) Append(h0, h1 Hash, compressed Key) {
	rp.proof.Append(h0, h1, compressed)
}

// A WriteProof is just a ReadProof for the old value, which verifies that the peer hashes
// correspond to the starting state root.  If there is an old value or if the node existed with
// an empty value, then the substitution of the new value hash allows us to verify the ending
// state root.  When neither of those occur, we have two cases: (1) the tree ended *before* the
// key for the new value is reached, in which case we had to extend the tree; (2) the key for
// the new value ends within the compressed key of an existing node (no old value), and we had
// to split that compressed node.  In either case, the replacement nodes for the new ADS is
// added to new_path.
//
// Verification of the write will be to slice the prefix of peerVerify.path to stop at the
// point where the subtree diverges (last entry of ReadProof), append newPath, and verify the
// path hash using the same membership machinery as for verifying a ReadProof.
type WriteProof struct {
	peerVerify ReadProof
	newPath    []NodeEntry
}

func (wp *WriteProof) Append(h0, h1 Hash, compressed Key) {
	wp.peerVerify.Append(h0, h1, compressed)
}

func (wp *WriteProof) SetOrigValueHash(h Hash) {
	wp.peerVerify.proof.extra = h
}

// Returns true if the proof may be valid at this recursion depth.  Do we need to create a
// non-recursive version of the algorithm?  Required stack depth is number of bits in the key.
// The non-recursive version should be pretty straightforward -- we could use an explicit stack
// and loop, but an iterative approach that uses key.GetBit and start at the end should work.
//
// We could just have nullHash to indicate the subproof was invalid, rather than use a bool,
// since AFAIK nobody knows how to get the preimage for nullHash for sha256.
func (mp MembershipProof) ProofHash(key Key, vh Hash, ix int) (Hash, bool) {
	if key.IsEmpty() {
		// base case
		if len(mp.path)-1 != ix {
			return nullHash, false
		}
		// Last entry should contain either an entry with an empty compressedKey, in
		// which case the vh was what was found (may be EmptyHash() so what was found
		// was "not-present"), or a non-empty compressedKey, in which case vh had
		// better be "not-present".
		if mp.path[ix].compressedKey.NumBits() != 0 {
			// This node contains data for a descendent node.
			if !vh.IsNull() {
				// Not-found should be the answer, but vh is not null: proof is
				// invalid.
				return nullHash, false
			}
			// Bubble up the hash.  mp.extra has the value hash for the last node
			// that proves non-membership.
			return HashNodeData(mp.path[ix].peer0, mp.extra, mp.path[ix].peer1, mp.path[ix].compressedKey), true
		}
		// Found node that should contain the datum.  We do not get vh from the node,
		// since the client knows it and supplied the expected value.  Compute hash of
		// peers and vh and compressedKey
		return HashNodeData(mp.path[ix].peer0, vh, mp.path[ix].peer1,
			mp.path[ix].compressedKey), true
	}
	// which way do we walk down the tree?
	dir, keyPrime := key.MSBAndDerive()
	childHash, ok := mp.ProofHash(keyPrime, vh, ix+1)
	if dir == 0 {
		if !ok {
			return nullHash, false
		}
		return HashNodeData(childHash, mp.path[ix].peer0, mp.path[ix].peer1, mp.path[ix].compressedKey), true
	} else {
		// right
		if !ok {
			return nullHash, false
		}
		return HashNodeData(mp.path[ix].peer0, mp.path[ix].peer1, childHash, mp.path[ix].compressedKey), true
	}
}

func (mp MembershipProof) Verify(key Key, vh Hash, expected Hash) bool {
	actual, valid := mp.ProofHash(key, vh, 0)
	return valid && actual.Equal(expected)
}
